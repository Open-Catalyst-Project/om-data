"""lammps2omm.py 
Author: Muhammad R. Hasyim

Module to convert LAMMPS force field and DATA files to OpenMM
XML force field file and PDB file. The script is only tested with 
The forcefield files contained in './ff' directory 
and for the following LAMMPS types 
    1. pair_coeff (LJ)
    2. bond_coeff
    3. angle_coeff
    4. dihedral_coeff
    5. improper_coeff

The script is heavily modified from:
'https://github.com/mrat1618/ff-conversion-openmm/lammps2omm.py'
'https://github.com/mrat1618/ff-conversion-openmm/main.lammps.py'
"""

import xml.etree.ElementTree as ET
import re
import json
from json import encoder
encoder.FLOAT_REPR = lambda o: format(o, '.15f')
import string
import MDAnalysis as mda
from pathlib import Path
import math
import numpy as np
import contextlib
from itertools import combinations
import subprocess
from rdkit.Chem import GetPeriodicTable


def remove_duplicate_lines(long_string):
    # Split the long string into individual lines
    lines = long_string.splitlines()

    # Use a set to store unique lines
    unique_lines = set(lines)

    # Join the unique lines back into a single string
    unique_string = "\n".join(unique_lines)

    return unique_string

def generate_molres(length):
    molres = []
    alphabet = string.ascii_uppercase
    num_alphabet = len(alphabet)
    
    for i in range(length):
        if i < num_alphabet:
            letter = alphabet[i]
            molres.append(letter * 3)
        else:
            number = i - num_alphabet + 1
            molres.append(str(number) * 3)
    
    return molres

def find_elem_by_mass(target, tol=0.1):
    pt = GetPeriodicTable()
    closest_elem = None
    closest_diff = float('inf')
    
    for num in range(1, 119):  # Iterating over known atomic numbers (1 to 118)
        symbol = pt.GetElementSymbol(num)
        
        mass = pt.GetAtomicWeight(num)
        diff = abs(mass - target)
        if diff <= closest_diff and diff <= tol:
            closest_diff = diff
            closest_elem = symbol
    return closest_elem

## Conversion units
radian2degree = 57.2957795130  # 1 rad  = 57.2957795130 degree
degree2radian = 0.0174533      # Reciprocal of degree2radian
kcal2kj       = 4.184          # 1 kcal = 4.184 kj
ang2nm        = 0.1            # 1 Angstrom = 0.1 nanometers

## grey colour bash text variable. marks unconverted lines in less pronounced light grey colour.
CGREY = '\33[90m'
CYLW = '\33[33m'
CEND = '\33[0m'

## Data from LAMMPS DATA file

lmp_id = [] 
lmp_type = [] 
lmp_mass = [] 

lmp_bondtype = [] 
lmp_bond_ids = [] 

lmp_angletype = [] 
lmp_angle_ids = []

lmp_dihedraltype = []
lmp_dihedral_ids = []

lmp_impropertype = []
improper_atomids_list = []

lmp_alltypes = []
lmp_allids = []
lmp_allels = []
lmp_allcharges = []

## Force field styles from *.in.init file generated by Moltemplate
bondstyles = []
anglestyles = []
dihedralstyles = []
improperstyles = []
pairstyles = []

## Data from PDB file generated by Packmol
pdb_ids_mol = []
pdb_names = []
pdb_resname_mol = []
pdb_resnames = []

def prep_openmm_md(filename,cat,an,solv,Nmols,directory):
    # Check filename if it is solvent vs. system.
    with contextlib.chdir(directory):
        lmpdata_file = filename+".data"
        pdb_file = filename+".pdb"
        if Path(lmpdata_file).is_file() and Path(pdb_file).is_file():
            # Load LAMMPS data file as a Universe object in MDAnalysis. 
            # We use this to write a new PDB file for the inital configuration.
            # and re-write the topology information. 
            u = mda.Universe(lmpdata_file)
            Natoms = len(u.atoms)
            u.add_TopologyAttr('record_types',['HETATM']*Natoms)

            # Open the LAMMPS data file manually and read + store topology info. 
            grab_lmpdata_attr(lmpdata_file)

            # Add new topology attributes to remove warnings
            # TO-DO: Find cleaner way to get this exception
            # In GAFF, element names have additional designation. Clean that to provide the core element name. 
            # Example, oxygen in double bond is 'Os'. Let's turn that into 'O'
            for i, ell in enumerate(lmp_allels):
                if 'Os' ==  ell:
                    lmp_allels[i] = 'O'
            u.add_TopologyAttr('elements',lmp_allels)
            
            #For chainIDs, distinguish whether the atom is part of solute (A) or solvent (B)
            #u.add_TopologyAttr('chainIDs',['A']*Natoms)
            u.add_TopologyAttr('altLocs',['']*Natoms)
            u.add_TopologyAttr('icodes',['']*len(u.residues))
            u.add_TopologyAttr('tempfactors',[0]*Natoms)
            u.add_TopologyAttr('occupancies',[1.0]*Natoms)

            # Open the corresponding PDB file (generated by packmol)
            grab_pdbdata_attr(pdb_file)
           
            # ChainIDs should distinguish between solvent and solute
            chainIDs = []
            molres = generate_molres(len(cat+an+solv))#[]
            soltorsolv = len(cat + an)*['solute']+len(solv)*['solvent']
            chainIDs = ['A' if soltorsolv[molres.index(resname)] == 'solute' else 'B' for resname in pdb_resnames]
            u.add_TopologyAttr('chainIDs',chainIDs)#['A']*Natoms)
            u.add_TopologyAttr('names',pdb_names)
            u.add_TopologyAttr('resnames',pdb_resname_mol)

            # Write the OpenMM Xml force field file
            write_forcefield(u,filename)

            # Write the OpenMM PDB file
            write_pdbfile(u,filename)

            write_metadata(cat,an,solv,Nmols,filename)
        
            # Next check the settings file and see if LAMMPS hybrid style is even necessary
            # Begin by reading the entire contents of the *in.settings file
            with open(f'{filename}.in.settings', 'r') as file:
                lines = file.readlines()
            string = ""
            for i, line in enumerate(lines):
                if "dihedral_coeff" in line and ('opls' in line or 'fourier' in line):
                    string += line.split()[2]
        
            if 'opls' in string and 'fourier' in string:
                print("No modification necessary. Hybrid style is present")
            else:
                print("Modification necessary. Only either opls/fourier style present")
            
                #First we modify the lines containing dihedral_coeff and delete the keyword for opls and fourier
                for i, line in enumerate(lines):
                    if "dihedral_coeff" in line and ('opls' in line or 'fourier' in line):
                        modified_line = line.replace('opls', '')
                        modified_line = modified_line.replace('fourier', '')
                        lines[i] = modified_line
                with open(f'{filename}.in.settings', 'w') as file:
                    file.writelines(lines)
            
                # Next, modify the *in.init file. We need to remove the hybrid keyword from that file.
                with open(f'{filename}.in.init', 'r') as file:
                    lines = file.readlines()
                for i, line in enumerate(lines):
                    if "dihedral_style" in line and ('opls' in line or 'fourier' in line):
                        modified_line = line.replace('hybrid', '')
                        if 'opls' in string:
                            modified_line = modified_line.replace('fourier', '')
                        if 'fourier' in string:
                            modified_line = modified_line.replace('opls', '')
                        lines[i] = modified_line
                with open(f'{filename}.in.init', 'w') as file:
                    file.writelines(lines)
        else:
            print(f"Eiher {lmpdata_file} or {pdb_file} don't exist. Not an error, but check if system is molten salt/ionic liquid")

def write_metadata(cat,an,solv,nmols,filename):
    metadata = {}
    metadata["species"] = cat+an+solv
    molres = []
    for i, letter in enumerate(string.ascii_uppercase[:len(cat+an+solv)]):
        molres.append(letter*3)
    metadata["residue"] = molres
    metadata["solute_or_solvent"] = len(cat + an)*['solute']+len(solv)*['solvent'] 
    metadata["partial_charges"] = lmp_allcharges
    metadata["composition"] = nmols
    with open(f"metadata_{filename}.json","w") as f:
        j = json.dumps(metadata,indent=4)
        f.write(j)
def _get_types(line):
    """ Obtain atom ids, mass, and types from LAMMPS DATA file
        
        Args:
            line (string): A string obtained from a line in LAMMPS DATA file
    """
    
    global lmp_id
    global lmp_mass
    global lmp_type

    line = line.split()
    lmp_id.append(int(line[0]))
    lmp_mass.append(float(line[1]))
    lmp_type.append(line[3].lower())

def _get_atoms(line):
    """ Obtain per-atom types, ids, element names, and charges from LAMMPS DATA file

        Args:
            line (string): A string obtained from a line in LAMMPS DATA file
    """
    
    global lmp_alltypes
    global lmp_allids
    global lmp_allels
    global lmp_allcharges

    line = line.split()
    lmp_alltypes.append(lmp_type[int(line[2])-1])
    lmp_allids.append(int(line[2]))
    elname = extract_and_capitalize(lmp_type[int(line[2])-1])
    lmp_allels.append(elname)
    lmp_allcharges.append(float(line[3]))
    
def _get_bondtypes(line):
    """ Obtain bond type and ids of connected atoms from LAMMPS data file
        
        Args:
            line (string): A string obtained from a line in LAMMPS DATA file
    """
    
    global lmp_bondtype
    global lmp_bond_ids

    line = line.split()
    lmp_bondtype.append(int(line[1]))
    lmp_bond_ids.append((int(line[2]),int(line[3])))

def _get_angletypes(line):
    """ Obtain angle type and ids of connected atoms from LAMMPS data file
        
        Args:
            line (string): A string obtained from a line in LAMMPS DATA file
    """
    
    global lmp_angletype
    global lmp_angle_ids

    line = line.split()
    lmp_angletype.append(int(line[1]))
    lmp_angle_ids.append((int(line[2]),int(line[3]),int(line[4])))

def _get_dihedraltypes(line):
    """ Obtain dihedral type and ids from LAMMPS data file
        
        Args:
            line (string): A string obtained from a line in LAMMPS DATA file
    """
    
    global lmp_dihedraltype
    global lmp_dihedral_ids

    line = line.split()
    lmp_dihedraltype.append(int(line[1]))
    lmp_dihedral_ids.append((int(line[2]),int(line[3]),int(line[4]),int(line[5])))

def _get_impropertypes(line):
    """ Obtain improper type and ids from LAMMPS data file
        
        Args:
            line (string): A string obtained from a line in LAMMPS DATA file
    """
    
    global lmp_impropertype
    global lmp_improper_ids
    
    line = line.split()
    lmp_impropertype.append(int(line[1]))
    improper_atomids_list.append((int(line[2]),int(line[3]),int(line[4]),int(line[5])))

"""Helper function to extract molecule name from the filename""" 
extract_and_capitalize = lambda text: re.match(r'([A-Za-z]+)', text).group(1).capitalize() if re.match(r'([A-Za-z]+)', text) else None

def write_pdbfile(u,filename):
    """Writes the final PDB file used for initializing OpenMM simulation

    Args:
        u (MDAnalysis.Universe): A Universe object loaded from LAMMPS DATA file
        filename (string): Name of PDB file pre-appended to the formatted name. 
    """
    
    #First, write the PDB file from Universe object
    fname = filename+'_init.pdb'
    ag = u.atoms
    ag.write(fname)
    
    #Make sure to generate CONECT information!
    pdbconect = ""
    for i, bond in enumerate(lmp_bond_ids):
        pdbconect += f"CONECT {bond[0]:>{4}} {bond[1]:>{4}} \n"
    pdbconect += "END \n"

    #Load the written PDB file again and delete the 'END' line 
    with open(fname,'r') as file:
        lines = file.readlines()
    if lines:
        lines.pop()
    with open(fname, 'w') as file:
        file.writelines(lines)

    # Now, append the PDB CONECT information
    with open(fname, 'a') as file:
        file.write(pdbconect)
    
    # Next, run PDBFixer, so that we have a clean initial configuration file
    subprocess.run(f'pdbfixer {fname}',shell=True)
    subprocess.run(f'mv output.pdb {fname}',shell=True)

def write_forcefield(u,filename):
    """Writes the final XML file used for performing an OpenMM simulation

    Args:
        u (MDAnalysis.Universe): A Universe object loaded from LAMMPS DATA file
        filename (string): Name of XML file pre-appended to the formatted name. 
    """
    
    global bondstyles
    global anglestyles
    global dihedralstyles
    global improperstyles
    global pairstyles
    
    # Read the *.in.init file to check what force field styles are present
    fname = filename+'.in.init'
    with open(fname,'r') as params:
        for line in params:
            cleaned_line = line.strip()
            if len(cleaned_line) >= 1 and cleaned_line.split()[0] == "bond_style":
                bondstyles = cleaned_line.split()[1:]
            if len(cleaned_line) >= 1 and cleaned_line.split()[0] == "angle_style":
                anglestyles = cleaned_line.split()[1:]
            if len(cleaned_line) >= 1 and cleaned_line.split()[0] == "dihedral_style":
                dihedralstyles = cleaned_line.split()[1:]
            if len(cleaned_line) >= 1 and cleaned_line.split()[0] == "improper_style":
                improperstyles = cleaned_line.split()[1:]
            if len(cleaned_line) >= 1 and cleaned_line.split()[0] == "pair_style":
                pairstyles = cleaned_line.split()[1:]

    # Read the *.in.settings to load the force field parameters
    bond_out = []
    angle_out = []
    torsion_out = []
    nonbond_out = []
    
    # Load the *.in.settings file
    fname = filename+'.in.settings'
    with open(fname, 'r') as params:
        # Grab all force field parameters
        for line in params:
            cleaned_line = line.strip()
            if len(cleaned_line) >= 1 and cleaned_line.split()[0] == "bond_coeff":
                bond_out.append(_bond(cleaned_line))
            elif len(cleaned_line) >= 1 and cleaned_line.split()[0] == "angle_coeff":
                angle_out.append(_angle(cleaned_line))
            elif len(cleaned_line) >= 1 and cleaned_line.split()[0] == "dihedral_coeff":
                torsion_out.append(_dihedral(cleaned_line))
            elif len(cleaned_line) >= 1 and cleaned_line.split()[0] == "improper_coeff":
                torsion_out.append(_improper(cleaned_line))
            elif len(cleaned_line) >= 1 and cleaned_line.split()[0] == "pair_coeff":
                nonbond_out.append(_nonbonding(cleaned_line))
            print(CGREY+cleaned_line+CEND)

    # Start writing the XML file
    omm_ff = filename+'.xml'
    with open(omm_ff,"w") as ff:
        ff.write("<ForceField>\n")
        
        # Write the Atom Types
        ff.write("<AtomTypes>\n")
        for i, atomtype in enumerate(lmp_type):
            elname = find_elem_by_mass(lmp_mass[i],tol=0.1)
            ff.write(f' <Type name="{atomtype}" class="{elname}" element="{elname}" mass="{lmp_mass[i]}"/> \n')
        ff.write("</AtomTypes>\n")
        
        # Generate the residue template and write the result. 
        residue_template = write_restemplate(u)
        ff.write(residue_template)
        
        #Next, we write the force field parameters
        
        #(1) Bond Interactions, use harmonic style
        # see https://docs.lammps.org/bond_harmonic.html for details
        bond_out = list(filter(lambda x: x is not None, bond_out))
        harmonic_bonds = list(filter(lambda x: x[0] == 'harmonic', bond_out))
        ff.write('<HarmonicBondForce>\n')
        for line in harmonic_bonds:
            ff.write(line[1]+"\n")
        ff.write('</HarmonicBondForce>\n')
        
        #(2) Angle Interactions, use harmonic style
        # see https://docs.lammps.org/angle_harmonic.html
        angle_out = list(filter(lambda x: x is not None, angle_out))
        harmonic_angles = list(filter(lambda x: x[0] == 'harmonic', angle_out))
        ff.write('<HarmonicAngleForce>\n')
        for line in harmonic_angles:
            ff.write(line[1]+"\n")
        ff.write('</HarmonicAngleForce>\n')
        
        #(3) Improper Interactions, uses cvff style
        # see https://docs.lammps.org/improper_cvff.html for details
        # filter out any Nones
        torsion_out = list(filter(lambda x: x is not None, torsion_out))
        impropers = list(filter(lambda x: x[0] == 'improper', torsion_out))
        cvff_impropers = list(filter(lambda x: x[1] == 'cvff', impropers))
        ff.write('<PeriodicTorsionForce>\n')
        for line in cvff_impropers:
            ff.write(line[2]+"\n")
        ff.write('</PeriodicTorsionForce>\n')
        
        #(4) Dihedral Interactions, uses two styles
        # First style is OPLS as described in https://docs.lammps.org/dihedral_opls.html
        # Second style is Fourier as desxribed in org/dihedral_fourier.html
        # Most molecules use the OPLS style, with a few exceptions.
        dihedrals = list(filter(lambda x: x[0] == 'dihedral', torsion_out))
        opls_dihedrals = list(filter(lambda x: x[1] == 'opls', dihedrals))
        if opls_dihedrals:
            ff.write('<PeriodicTorsionForce>\n')
            for line in opls_dihedrals:
                ff.write(line[2]+"\n")
            ff.write('</PeriodicTorsionForce>\n')
        
        fourier_dihedrals = list(filter(lambda x: x[1] == 'fourier', dihedrals))
        if fourier_dihedrals:
            for line in fourier_dihedrals:
                number = len(re.findall(r'k\d+="', line[2]))
                ff.write('<CustomTorsionForce energy=')
                if number == 1:
                            ff.write(f'"k1*(1+cos(n1*theta-d1))')
                else:
                    for i in range(1,number+1):
                        if i < number:
                            if i == 1:
                                ff.write(f'"k{i}*(1+cos(n{i}*theta-d{i}))+')
                            else:
                                ff.write(f'k{i}*(1+cos(n{i}*theta-d{i}))+')
                        else:
                            ff.write(f'k{i}*(1+cos(n{i}*theta-d{i}))')
                ff.write('">\n')
                for i in range(1,number+1):
                    ff.write(f"""<PerTorsionParameter name="k{i}"/>
    <PerTorsionParameter name="n{i}"/>
    <PerTorsionParameter name="d{i}"/>
    """)
                ff.write(line[2]+"\n")
                ff.write('</CustomTorsionForce>\n') 

        #(5) NonBonded Interaction, includes Lennard-Jones and Coulomb interaction 
        # The coulomb14scale and lj14scale specifies the 1-4 interaction scale for 
        # Coulombic and Lennard-Jones interactions, respectively. 
        # The choice of 0.5 is derived from OPLS specifications,
        # see https://zarbi.chem.yale.edu/ligpargen/openMM_tutorial.html for details
        nonbond_out = list(filter(lambda x: x is not None, nonbond_out))
        ff.write('<NonbondedForce coulomb14scale="0.5" lj14scale="0.5">\n')
        for line in nonbond_out:
            ff.write(line[0]+"\n")
        ff.write('</NonbondedForce>\n')
        
        ff.write("</ForceField>\n")
    ff.close()


def find_combination(numbers_list, target_tuple):
    """Helper function to check if a pair of numbers is present in all possible combinations of a list
    
        Args: 
        numbers_list (list): A list of all possbile numbers
        target_typle (tuple): A tuple of numbers to match with the combinations of numbers_list
    """
    num1, num2 = target_tuple
    return num1 in numbers_list and num2 in numbers_list
def write_restemplate(u):
    """Generates a residue template for the XML force field file
    
        Args: 
            u (MDAnalysis.Universe): A Universe object loaded from the LAMMPS DATA file
    """
    
    text = "<Residues>\n"
    resnames = list(set(pdb_resname_mol))
    for resname in resnames:
        text += f' <Residue name="{resname}">\n'
        bond_text = ""
        names = []
        types = []
        
        #Go through and write the bond information
        for i, bond in enumerate(lmp_bond_ids):
            if u.atoms[bond[0]-1].resname == resname and find_combination(pdb_ids_mol,bond):
                names.append(u.atoms[bond[0]-1].name)      
                names.append(u.atoms[bond[1]-1].name)      
                types.append(lmp_alltypes[bond[0]-1])
                types.append(lmp_alltypes[bond[1]-1])
                bond_text += f'  <Bond atomName1="{pdb_names[bond[0]-1]}" atomName2="{pdb_names[bond[1]-1]}" /> \n'
        #Remove duplicate lines in the bond text we read
        bond_text = remove_duplicate_lines(bond_text)  
        
        #Re-order the bond entries
        wrapped_bonds_string = f"<root> \n {bond_text} </root>"

        root = ET.fromstring(wrapped_bonds_string)

        bonds = root.findall('Bond')

        sorted_bonds = sorted(bonds, key=lambda x: x.get('atomName2'))

        new_root = ET.Element('root')

        for bond in sorted_bonds:
            new_root.append(bond)

        bond_text = ET.tostring(new_root, encoding='unicode').replace('<root>', '').replace('</root>', '')
        
        #Write the atom names and types associated with the bond information
        if types and names:
            r, d = zip(*((r, types[i]) for i, r in enumerate(names) if r not in names[:i]))
            for i in range(len(r)):
                text += f'  <Atom name="{r[i]}" type="{d[i]}"/> \n'
            text += bond_text
        
        #If either no bonds are present, then we have a single atom, i.e., Na+ ion or Cl- ion.
        else:
            idx = pdb_resnames.index(resname)
            text += f'  <Atom name="{pdb_names[idx]}" type="{lmp_alltypes[idx]}"/> \n'
        text += ' </Residue>\n'
    text += "</Residues>\n"
    return text

def grab_pdbdata_attr(pdb_file):
    """Reads the data from PDB file and store them into lists

        Args: 
            pdb_file (string): fname of the PDB file to load
        
        The lists that we modify are:
            - pdb_ids_mol: store 
            - pdb_names: store the chainID from the PDB file, which is alphabetical, e.g., A, B, C, and so on. 
            - pdb_resnames: store residue name from the PDB file. Here, we override any residue name
              from the pdb file and give a residue name as a triple of the chain ID. Thus, 
              chainID A -> AAA, B -> BBB, etc.
    """
    with open(pdb_file, 'r') as file:
        lines = file.readlines()
        chainID = []
        molID = []
        molid = 0
        
        for line in lines:
            lsplit = line.split()
            if lsplit[0] == 'ATOM' or lsplit[0] == 'HETATM':
                if lsplit[4] not in chainID:
                    chainID.append(lsplit[4])
                    molID.append(lsplit[5])
                    molid = 0
                if molID[-1] == lsplit[5]:
                    pdb_ids_mol.append(int(lsplit[1]))
                pdb_names.append(str(lsplit[2]))
                if len(lsplit[4]) == 1:
                    pdb_resnames.append(str(lsplit[4]*3))
                else:
                    pdb_resnames.append(str(lsplit[4][0]*3))
                try:
                    if np.abs(molid-int(lsplit[5])) > 0:
                        pdb_resname_mol.append(str(lsplit[4]*3))
                        molid = int(lsplit[5])
                except Exception as e:
                    if np.abs(molid-int(lsplit[4][1:])) > 0:
                        pdb_resname_mol.append(str(lsplit[4][0]*3))
                        molid = int(lsplit[4][1:])

def grab_lmpdata_attr(dname):
    """Reads the data from LAMMPS data file and store them into lists

        Args: 
            dname (string): fname of the LAMMPS DATA file to load
        
        The lists that we modify are:
            - lmp_id
            - lmp_mass
            - lmp_type
            - 
    """
    global lmp_id
    global lmp_mass
    global lmp_type

    namelist = ["Masses","Atoms","Bonds","Angles","Dihedrals","Impropers"]
    checks = [False]*len(namelist)
    with open(dname,"r") as params:
        for line in params:
            cleaned_line = line.strip()
            for name in namelist:
                if name in cleaned_line:
                    checks = [False]*len(namelist)
                    idx = namelist.index(name)
                    checks[idx] = True
            if checks[0] and len(cleaned_line.split()) == 4:
                _get_types(cleaned_line)
                sorted_indices = [index for index, _ in sorted(enumerate(lmp_id), key=lambda x: x[1])]
                lmp_id = np.array(lmp_id)[sorted_indices].tolist()
                lmp_mass = np.array(lmp_mass)[sorted_indices].tolist()
                lmp_type = np.array(lmp_type)[sorted_indices].tolist()
            if checks[1] and len(cleaned_line.split()) == 7:
                _get_atoms(cleaned_line)
            if checks[2] and len(cleaned_line.split()) == 4:
                _get_bondtypes(cleaned_line)
            if checks[3] and len(cleaned_line.split()) == 5:
                _get_angletypes(cleaned_line)
            if checks[4] and len(cleaned_line.split()) == 6:
                _get_dihedraltypes(cleaned_line)
            if checks[5] and len(cleaned_line.split()) == 6:
                _get_impropertypes(cleaned_line)

## TO-DO: Update the documentation stings

def _bond(line):
    """Process LAMMPS harmonic bond style parameters into OpenMM HarmonicBondForce parameters. 
    
        Args: 
            line (string): a string obtained from a line in LAMMPS data file

        K: kcal/mol/(A**2)  ->  K/2: 2*kj/mol/nm**2 (scale factor 2)
        r: Ang                ->  nm
    ----
    bond_coeff  1  338.69999999999999        1.0910000000000000  
    0           1  2                         3                      
                   ^                         ^
                   K                         r
    """
    llist     = line.split()
    bond_type = int(llist[1])
    k         = float(llist[2])
    r         = float(llist[3])

    omm_k  = k*2*kcal2kj/(ang2nm*ang2nm)
    omm_r  = r*ang2nm
    
    idx = lmp_bondtype.index(bond_type)# = []
    aid, bid = lmp_bond_ids[idx]
    aid = lmp_alltypes[aid-1]
    bid = lmp_alltypes[bid-1]
    bond_style = bondstyles[0]
    omm_out = ' <Bond type1="{}" type2="{}" length="{}" k="{}"/>'.format(aid,bid,omm_r, omm_k)
    
    print(omm_out)
    return [bond_style,omm_out] 


def _angle(line):
    """Process LAMMPS harmonic angle style parameters into OpenMM HarmonicAngleForce parameters. 
    
        Args: 
            line (string): a string obtained from a line in LAMMPS data file
        K: kcal/mol/(rad**2)  ->  K/2: 2*kj/mol/(rad**2) (scale factor 2)
        a: degrees            ->  rad
    ----
    angle_coeff  1  46.200000000000010        110.10999693591019  
    0            1  2                         3                   
                    ^                         ^              
                    K                         a    
    """
    llist  = line.split()
    angle_type = int(llist[1])
    k      = float(llist[2])
    a      = float(llist[3])
    
    idx = lmp_angletype.index(angle_type)
    aid, bid, cid = lmp_angle_ids[idx]
    omm_t1 = lmp_alltypes[aid-1]
    omm_t2 = lmp_alltypes[bid-1]
    omm_t3 = lmp_alltypes[cid-1]

    omm_k  = 2*k*kcal2kj
    omm_a  = math.radians(a)

    angle_style = anglestyles[0]
    omm_out = ' <Angle type1="{}" type2="{}" type3="{}" angle="{}" k="{}"/>'.format(omm_t1, omm_t2, omm_t3, omm_a, omm_k)

    print(omm_out)
    return [angle_style,omm_out]


def _dihedral(line):
    """Process LAMMPS dihedral style parameters into OpenMM PeriodicTorsionForce (for opls) or CustomTorsionForce (for fourier) parameters. 
    
        Args: 
            line (string): a string obtained from a line in LAMMPS data file
        
        For opls style, we have four different force constants. Unit converrsion follows:
        K1,K2,K3,K4: kcal/mol                      ->  k1,k2,k3,k4: (1/2)kj/mol (scale factor 1/2)
        Periodicity and phase offsets will be hardcoded to exactly replicate LAMMPS opls style

        For fourier style, we have n-many force constants (Kn), periodicity (n), and phase offset (dn). 
        Unit conversion for force constant is the same as opls style. Periodicity and phase offset follows exactly the prescription
        from LAMMPS (see https://docs.lammps.org/dihedral_fourier.html for details)
        
        Because the style can be hybrid (or not) we check if the length of dihedralstyles list is more than one
    ----
    In hybrid mode:

    dihedral_coeff  1  opls     1.740    -0.157     0.270     0.00
    0               1  2        3         4         5         6             
                                ^         ^         ^         ^  
                                K1        K2        K3        K4   
    dihedral_coeff  1  fourier  3   -0.846200   3   0.0     7.578800    1   0       0.138000    2       -180.0
    0               1  2        3    4          5   6       7           8   9       10          11       12      
                                ^    ^          ^   ^       ^           ^   ^       ^           ^        ^
                                m    K1         n1  d1      K2          n2  d2      K3          n3       d3
    ----
    When not in hybrid mode, the specification of opls/fourier do not exist and so the length of 'line' argument decreases
    """
    llist  = line.split()
    
    #Check if we are in hybrid mode or not
    shift = 0
    dihedral_type = int(llist[1])
    if len(dihedralstyles) > 1:
        shift = 1
        dihedral_style = llist[1+shift] 
    else:
        dihedral_style = dihedralstyles[0]
    
    idx = lmp_dihedraltype.index(dihedral_type)# = []
    aid, bid, cid, did = lmp_dihedral_ids[idx]
    omm_t4 = lmp_alltypes[aid-1]
    omm_t3 = lmp_alltypes[bid-1]
    omm_t2 = lmp_alltypes[cid-1]
    omm_t1 = lmp_alltypes[did-1]

    if dihedral_style == "opls":
        k1 = float(llist[2+shift])/2
        k2 = float(llist[3+shift])/2
        k3 = float(llist[4+shift])/2
        k4 = float(llist[5+shift])/2

        omm_k1  = k1 * kcal2kj
        omm_k2  = k2 * kcal2kj
        omm_k3  = k3 * kcal2kj
        omm_k4  = k4 * kcal2kj

        omm_out = ' <Proper type1="{}" type2="{}" type3="{}" type4="{}" k1="{}" k2="{}" k3="{}" k4="{}" periodicity1="1" periodicity2="2" periodicity3="3" periodicity4="4" phase1="0.00" phase2="3.141592653589793" phase3="0.00" phase4="3.141592653589793"/>'.format(omm_t1, omm_t2, omm_t3, omm_t4, omm_k1, omm_k2, omm_k3, omm_k4)

        print(omm_out)
        return ["dihedral",dihedral_style,omm_out]
    
    elif dihedral_style == "fourier":
        nterms = int(llist[2+shift])
        k = []
        n = []
        d = []
        omm_out = ' <Proper type1="{}" type2="{}" type3="{}" type4="{}" '.format(omm_t1, omm_t2, omm_t3, omm_t4)
        for i in range(nterms):
            omm_out += f' k{i+1}="{float(llist[3*i+3+shift])*kcal2kj}"'
            omm_out += f' n{i+1}="{float(llist[3*i+4+shift])}"'
            omm_out += f' d{i+1}="{float(llist[3*i+5+shift])}"'
        omm_out += '/>'
        
        print(omm_out)
        return ["dihedral",dihedral_style,omm_out]

def _improper(line):
    """Process LAMMPS improper style parameters into OpenMM PeriodicTorsionForce (for opls) 
    
        Args: 
            line (string): a string obtained from a line in LAMMPS data file
        
        K:kcal/mol                      ->  K: kj/mol
        periodicity(n): integer >= 0    ->  int
        d(phase offset): degrees        ->  rad
    
    ----
    improper_coeff  1  0.15559999999999999     3   0   
    0               1  2                       3   4   
                       ^                       ^   ^          
                       K                       n   d   
    """
    llist  = line.split()
    improper_type = int(llist[1])
    k = float(llist[2])
    d = float(llist[3]) 
    if d < 0:
        theta = np.pi
    else:
        theta = 0.0
    n = float(llist[4])

    idx = lmp_impropertype.index(improper_type)
    aid, bid, cid, did = improper_atomids_list[idx]
    omm_t4 = lmp_alltypes[aid-1]
    omm_t3 = lmp_alltypes[bid-1]
    omm_t2 = lmp_alltypes[cid-1]
    omm_t1 = lmp_alltypes[did-1]
    
    omm_k  = k * kcal2kj
    omm_n  = n
    omm_theta  = theta

    omm_out = ' <Improper type1="{}" type2="{}" type3="{}" type4="{}" periodicity1="{}" phase1="{}" k1="{}"/>'.format(omm_t1, omm_t2, omm_t3, omm_t4, int(omm_n),omm_theta,omm_k)

    print(omm_out)
    improper_style = improperstyles[0]
    return ["improper",improper_style,omm_out]


def _nonbonding(line):#,fixedtypes):
    """Process LAMMPS lj/cut/long/coul style parameters into OpenMM NonbondedForce parameters
    
        Args: 
            line (string): a string obtained from a line in LAMMPS data file
        epsilon: kcal/mol       ->  kj/mol
        sigma  : angstrom       ->  nm       
    ----
    pair_coeff   1 3   1.4000000000000000E-002   2.2645400000000002  
    0            1 2   3                         4                  
                       ^                         ^
                       epsilon                   sigma
    
    Any information related to cutoff parameters will be specified runtime (in the simulation script). OpenMM
    only needs the LJ parameters and partial charge, which is read previously from invoking function _get_atoms 
    """  
    llist = line.split()

    atom_id1 = llist[1]
    omm_t1 = lmp_type[int(atom_id1)-1]
    
    atom_id2 = llist[2]
    omm_t2 = lmp_type[int(atom_id2)-1]
    
    epsilon    = float(llist[3]) 
    sigma      = float(llist[4]) 
    omm_sigma   = ang2nm * sigma
    omm_epsilon = kcal2kj * epsilon

    # only output LJ pairs with same atom type
    # if type is not the same, we ignore
    if atom_id1 == atom_id2:
        idx = lmp_allids.index(int(atom_id1))
        omm_charge = lmp_allcharges[idx]# = []
        omm_out = ' <Atom type="{}" charge="{}" sigma="{}" epsilon="{}"/>'.format(omm_t2, omm_charge, omm_sigma, omm_epsilon)
        print(omm_out)
    else:
        print(CGREY + line.strip() + CEND)
        omm_out=""
    return [omm_out]
